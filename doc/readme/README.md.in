atJIT: A just-in-time autotuning compiler for C++
==========================================

[![Build Status](https://travis-ci.org/kavon/atJIT.svg?branch=master)](https://travis-ci.org/kavon/atJIT)

About
-----

atJIT is an early-phase experiment in online autotuning.

The code was originally based on the [Easy::jit](https://github.com/jmmartinez/easy-just-in-time) project.

Requirements
--------

First, install clang and LLVM. To do this on Ubuntu, you can simply install using the following command.

```bash
apt install llvm-6.0-dev llvm-6.0-tools clang-6.0
```

To use a custom-built clang + LLVM that is built from source, you will need to
configure your build with CMake in a special way, which can be done easily by adding the following `-C` flag to your usual invocation of CMake to load the config:

```bash
cmake -C <path-to-atJit-root>/cmake/LLVM.cmake  .. other arguments ..
```



Building
--------

Once you have clang and LLVM installed, configure and compile atJIT from the root of the project like so:

```bash
mkdir build install
cd build
cmake -DCMAKE_INSTALL_PREFIX=../install ..
cmake --build .
```

Once this completes, see the next section for usage.

##### Build Options

If you are using a custom LLVM that is not installed system-wide, you'll need to add `-DCMAKE_PREFIX_PATH=<path-to-where-LLVM-was-installed>` to the first CMake command above.

To build the examples, install the [opencv](https://opencv.org/) library,
and add the flags ```-DEASY_JIT_EXAMPLE=1``` to the cmake command.

To enable benchmarking, install the [google benchmark](https://github.com/google/benchmark) framework,
and add the flags ```-DEASY_JIT_BENCHMARK=1 -DBENCHMARK_DIR=<path_to_google_benchmark_install>``` to the cmake command.

<!--
### Docker

If you want to give only a quick test to the project, everything is provided to use it with docker.
To do this, generate a Dockerfile from the current directory using the scripts in ```<path_to_easy_jit_src>/misc/docker```,
then generate your docker instance.

```bash
python3 <path_to_easy_jit_src>/misc/docker/GenDockerfile.py  <path_to_easy_jit_src>/.travis.yml > Dockerfile
docker build -t easy/test -f Dockerfile
docker run -ti easy/test /bin/bash
```
-->

Basic usage
-----------

### Compiling my project with atJIT

Look in your install directory for the `bin/easycc` executable, which is a
thin wrapper around `clang++` with the correct arguments to run the
clang plugin and dynamically link in the runtime system.
You can use `easycc` as if it were `clang++`.
Here's an example:

```bash
➤ install/bin/easycc -O2 tests/simple/int_a.cpp -o int_a
➤ ./int_a
inc(4) is 5
inc(5) is 6
inc(6) is 7
inc(7) is 8
```

<!--
Since the Easy::Jit library relies on assistance from the compiler, its
mandatory to load a compiler plugin in order to use it.
The flag ```-Xclang -load -Xclang <path_to_easy_jit_build>/bin/EasyJitPass.so```
loads the plugin.

The included headers require C++17 support, and remember to add the include directories!
Use ```--std=c++17 -I<path_to_easy_jit_src>/cpplib/include```.

Finaly, the binary must be linked against the Easy::Jit runtime library, using
```-L<path_to_easy_jit_build>/bin -lEasyJitRuntime```.

Putting all together we get the command bellow.

```bash
clang++-6.0 --std=c++17 <my_file.cpp> \
  -Xclang -load -Xclang /path/to/easy/jit/build/bin/bin/EasyJitPass.so \
  -I<path_to_easy_jit_src>/cpplib/include \
  -L<path_to_easy_jit_build>/bin -lEasyJitRuntime
```
-->

### Using atJIT inside my project

*coming soon*

<!--

Consider the code below from a software that applies image filters on a video stream.
In the following sections we are going to adapt it to use the atJIT library.
The function to optimize is ```kernel```, which applies a mask on the entire image.

The mask, its dimensions and area do not change often, so specializing the function for
these parameters seems reasonable.
Moreover, the image dimensions and number of channels typically remain constant during
the entire execution; however, it is impossible to know their values as they depend on the stream.

```cpp
</include camfilter.cpp ORIGINAL/>
```

The main header for the library is ```easy/jit.h```, where the only core function
of the library is exported. This function is called -- guess how? -- ```easy::jit```.
We add the corresponding include directive them in the top of the file.

```cpp
</include camfilter.cpp INCLUDE_EASY/>
```

With the call to ```easy::jit```, we specialize the function and obtain a new
one taking only two parameters (the input and the output frame).

```cpp
</include camfilter.cpp EASY/>
```

#### Deducing which functions to expose at runtime

atJIT embeds the [LLVM bitcode](https://llvm.org/docs/LangRef.html)
representation of the functions to specialize at runtime in the binary code.
To perform this, the library requires access to the implementation of these
functions.
atJIT does an effort to deduce which functions are specialized at runtime,
still in many cases this is not possible.

In this case, it's possible to use the ```EASY_JIT_EXPOSE``` macro, as shown in
the following code,

```cpp
void EASY_JIT_EXPOSE kernel() { /* ... */ }
```

or using a regular expression during compilation.
The command bellow exports all functions whose name starts with "^kernel".

```bash
clang++ ... -mllvm -easy-export="^kernel.*"  ...
```

#### Caching

In parallel to the ```easy/jit.h``` header, there is ```easy/code_cache.h``` which
provides a code cache to avoid recompilation of functions that already have been
generated.

Bellow we show the code from previous section, but adapted to use a code cache.

```cpp
</include camfilter.cpp INCLUDE_EASY_CACHE/>
```

```cpp
</include camfilter.cpp EASY_CACHE/>
```

-->

License
-------

See file `LICENSE` at the top-level directory of this project.

Acknowledgements
------

Special thanks to Serge Guelton and Juan Manuel Martinez Caamaño for
originally developing Easy::jit.
